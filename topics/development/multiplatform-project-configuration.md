[//]: # (title: Choosing configuration for your Kotlin Multiplatform project)

There are different ways to structure your code when you add Kotlin Multiplatform to an existing project or start a new
one. Typically, you create one or more Kotlin Multiplatform shared modules and use them from your Android and iOS apps.

To choose the best approach for your case, consider the following questions:

* [How do you consume an iOS framework generated by a Kotlin Multiplatform module from the iOS app?](#connect-a-kotlin-multiplatform-module-to-ios-app)
  Do you integrate it directly, through CocoaPods or using the Swift package manager (SPM)?
* [Do you have one or several Kotlin Multiplatform shared modules?](#module-configurations)
  For several shared modules, what will be the umbrella module for them?
* [Do you store all the code in a monorepo or different repositories?](#repository-configurations)
* [Do you use a local or remote dependency?](#code-sharing-workflow)

Answering these questions helps you pick the best configuration for your project.

## Connect a Kotlin Multiplatform module to iOS app

To use a Kotlin Multiplatform shared module from an iOS app, you first need to generate
an [iOS framework](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/WhatAreFrameworks.html)
from this shared module. Then you should add it as a dependency to the iOS project:

![Kotlin Multiplatform shared module](kmp-shared-module.svg){width=700}

It's possible to consume this framework as a local or remote dependency.

You can add a dependency on a Kotlin Multiplatform module framework to the iOS project in one of the following ways:

* **Direct integration**. You connect the framework directly by adding a new run script phase to the build of the iOS
  app. See [Connect the framework to your iOS project](multiplatform-integrate-in-existing-app.md#connect-the-framework-to-your-ios-project)
  to learn how to do that in Xcode.

  When you create a project with a wizard, choose the **Regular framework** option to have this setup generated
  automatically.

* **CocoaPods integration**. You connect a framework through [CocoaPods](https://cocoapods.org/), a popular dependency
  manager for Swift and Objective-C projects. It might be either local or remote dependency. For more information,
  see [Use a Kotlin Gradle project as a CocoaPods dependency](https://kotlinlang.org/docs/native-cocoapods-xcode.html).

  To set up a workflow with a local CocoaPods dependency, you can either generate the project with a wizard, or edit the
  scripts manually.

* **Using SPM**. You connect a framework using the Swift package manager (SPM), an Apple tool for managing the
  distribution of Swift code. There's no [official support for SPM](https://youtrack.jetbrains.com/issue/KT-53877/Support-Swift-Package-Manager-in-Kotlin-Multiplatform)
  yet, but you can use the community supported solutions to set up a remote dependency on a Swift package, containing
  the Kotlin Multiplatform module framework.

   <!-- This tutorial [TODO] shows how to set up the remote distribution workflow. -->

## Module configurations

There are two module configuration options that you can use in Kotlin Multiplatform projects, using a single or several
shared modules.

### Single shared module

The simplest module configuration contains only a single Kotlin Multiplatform shared module in the project:

![Single shared module](single-shared-module.svg){width=700}

The Android app can depend on the Kotlin Multiplatform shared module as a regular Kotlin module. However, iOS doesn't
know anything about Kotlin, so the iOS app must depend on the iOS framework generated by the Kotlin Multiplatform
module.

<table>
  <tr>
     <th>Pros</th>
     <th>Cons</th>
  </tr>
  <tr>
  <td>
    <list>
       <li>Simple design with just a single module reduces cognitive load. You don't need to think about where to put your functionality or how to split it logically into parts.</li>
       <li>Works great as a starting point.</li>
</list>
</td>
<td>
<list>
  <li>Compilation time increases as the shared module grows.</li>
  <li>This design doesn't allow having separate features or having dependencies only on the features the app needs.</li>
</list>
</td>
</tr>
</table>

### Several shared modules

As your shared module grows, it's a good idea to break it into feature modules.
This helps you avoid scalability issues related to having just one module.

The Android app can depend on all feature modules directly or on some of them if necessary.

The iOS app can depend only on one framework generated by the Kotlin Multiplatform module, so when you use several
modules, you need to add an extra module depending on them and configure a framework containing all the modules. These
are an _umbrella module_ and an _umbrella framework_.

> The umbrella framework bundle contains all the project's shared modules and is imported into the iOS app.
>
{type="tip"}

<table>
  <tr>
     <th>Pros</th>
     <th>Cons</th>
  </tr>
  <tr>
  <td>
    <list>
       <li>Separation of concerns for shared code.</li>
       <li>Improved scalability.</li>
       </list>
</td>
<td>
<list>
  <li>More complicated setup, including the umbrella framework setup.</li>
 <li>More involved dependency management across modules.</li>
</list>
</td>
</tr>
</table>

#### Why do you need an umbrella framework {initial-collapse-state="collapsed"}

While it's possible to include several frameworks generated from different Kotlin Multiplatform shared modules in your iOS app,
we do not recommend this approach. When a Kotlin Multiplatform module is compiled into a framework, the resulting framework
includes all its dependencies. Whenever two or more modules use the same dependency, and these modules get exposed to iOS
as separate frameworks, the Kotlin/Native compiler duplicates this dependency. 

This duplication raises a number of difficulties. Firstly, the iOS app size is unnecessarily inflated. Secondly, a
particular dependency's code structure is incompatible with the duplicated dependency's code structure. This creates a
problem when trying to integrate two modules with the same dependencies within the iOS application. For instance, any
state passed by different modules through the same dependency won't be connected. It might lead to unexpected behavior
and easily create bugs. See the [TouchLab documentation](https://touchlab.co/multiple-kotlin-frameworks-in-application/)
for more details on the exact limitations.

Kotlin doesn't produce common framework dependencies to avoid this duplication for a reason. Any Kotlin binary you add
to your app needs to be as small as possible. Including the whole Kotlin runtime and all code from all dependencies
would almost certainly be a waste. The Kotlin compiler is able to trim the binary to exactly what it needs for this
build. However, it doesn't know what your other builds might need, so trying to share dependencies is not feasible.
We're exploring various options to minimize the effects of this issue.

The solution to this problem is to use an umbrella framework. It prevents the bloating of the iOS app with duplicated
dependencies, helps optimize the resulting artifact, and eliminates the frustrations caused by incompatibilities between
dependencies.

In this case, you add a separate module that depends on all feature modules and generate a framework from this module:

![Umbrella framework](umbrella-framework.svg){width=700}

The Android app can either depend on this umbrella module for consistency or on separate feature modules. Such an
umbrella module often contains useful utility functions and dependency injection setup code.

You might export only some of the modules to the umbrella framework, typically when the framework artifact is consumed
as a remote dependency. The main reason for this is not to unnecessarily increase the size of the final artifact, which
might be caused by including auto-generated code.

It's a known constraint of the umbrella framework approach that the iOS app can't use only some feature modules; it
automatically consumes all of them. For possible improvements to this functionality,
see [KT-42247](https://youtrack.jetbrains.com/issue/KT-42247)
and [KT-42250](https://youtrack.jetbrains.com/issue/KT-42250).

> When you see further that an iOS app depends on an umbrella module, it means that it depends on the umbrella framework
> generated from this module.
>
{type="tip"}

## Repository configurations

There are a number of repository configuration options that you can use in new and existing Kotlin Multiplatform
projects, using one repository or a combination of several repositories.

### Monorepo: everything in one repository

A common repository configuration is the so-called monorepo configuration. This approach is used in Kotlin Multiplatform
samples and tutorials. In this case, the repository contains both Android and iOS apps, as well as the shared module or
several modules, including the umbrella module:

![Monorepo configuration](monorepo-configuration-1.svg){width=700}
![Monorepo configuration](monorepo-configuration-2.svg){width=700}

Typically, the iOS app consumes the Kotlin Multiplatform shared module as a regular framework using direct or CocoaPods
integration. See [Connecting Kotlin Multiplatform module to iOS app](#connect-a-kotlin-multiplatform-module-to-ios-app)
for more details and links to tutorials.

If the repository is under version control, the apps and the shared module have the same version.

<table>
  <tr>
     <th>Pros</th>
     <th>Cons</th>
  </tr>
  <tr>
  <td>
    <list>
       <li>It's easy to set up with the help of wizards.</li>
       <li>iOS developers can easily work with Kotlin Multiplatform code since all the code is located in the same repository.</li>
</list>
</td>
<td>
<list>
  <li>iOS developers need to set up and configure unfamiliar tools.</li>
<li>It often doesn't work for existing apps already stored in different repositories.</li>
</list>
</td>
</tr>
</table>

When the existing Android and iOS apps are already stored in different repositories, you can add the Kotlin
Multiplatform part to an Android repository or to a separate repository instead of merging them.

### Two repositories: Android + shared | iOS

Another project configuration is having two repositories. In this case, the Kotlin Multiplatform repository contains
both the Android app and the shared module, including the umbrella module, while the Xcode project contains the iOS app:

![Two repository configuration](two-repositories.svg){width=700}

The Android and iOS apps can be versioned separately, and the shared module is versioned along with the Android app.

### Three repositories: Android | iOS | shared

One more option is having separate repositories for the Kotlin Multiplatform modules. In this case, the Android and iOS
apps are stored in separate repositories, and the project's shared code can contain multiple feature modules and the
umbrella module for iOS:

![Three repository configuration](three-repositories.svg){width=700}

Each project can be versioned separately. Kotlin Multiplatform modules must also be versioned and published for the
Android or JVM platforms. You can either publish feature modules independently or publish only the umbrella module and
make the Android app depend on it.

On the one hand, publishing Android artifacts separately might present an additional complexity for Android developers
compared to the two project scenarios when the Kotlin Multiplatform modules are a part of the Android project.

On the other hand, when both Android and iOS teams consume the same versioned artifacts, they operate in version parity,
and from a team perspective, that avoids the impression that the shared Kotlin Multiplatform code is "owned" by the
Android developers. For large projects that already publish versioned internal Kotlin and Swift packages for feature
development, publishing the shared Kotlin artifacts becomes a part of the workflow.

### Many repositories: Android | iOS | multiple libraries

When functionality should be shared between multiple apps on multiple platforms, you might prefer having many
repositories with Kotlin Multiplatform code. For example, you can store a logging library, which is common for the whole
product, in a separate repository with its own versioning.

In this case, you have multiple Kotlin Multiplatform library repositories. If several iOS apps use different subsets of
"library projects", each app can have an additional repository containing the umbrella module with the necessary
dependencies on the library projects:

![Many repository configuration](many-repositories.svg){width=700}

Here, each library must be versioned and published for the Android or JVM platforms as well. The apps and each library
can be versioned separately.

## Code sharing workflow

The iOS app can consume a framework generated from the Kotlin Multiplatform shared modules as a _local_ or _remote_
dependency. You can use a local dependency by providing a local path to the framework in the iOS build. In this case,
you don't need to publish the framework. Alternatively, you can publish an artifact with the framework somewhere and
make the iOS app consume it as a remote dependency, like any other third-party dependency.

### Local: source distribution

Local distribution refers to the scenario where the iOS app consumes a Kotlin Multiplatform module framework without the
need for publishing. The iOS app can either integrate the framework directly or using CocoaPods.

This workflow is typically used whenever both Android and iOS team members want to edit the shared Kotlin Multiplatform
code. The iOS developers need to install Android Studio and have a basic knowledge of Kotlin and Gradle.

In the local distribution scheme, the iOS app build triggers the generation of the iOS framework. It means that OS
developers can observe their changes to Kotlin Multiplatform code right away:

![Local source distribution](local-source-distribution.svg){width=700}

This scenario can be used in monorepo project configurations as the default workflow (without the need to publish
artifacts) and for local development in addition to the remote workflow.
See [Setting up a local dependency for local development](#setting-up-a-local-dependency-for-local-development) for more
details.

This workflow is most effective when all developers are ready to edit code in the whole project. It includes both
Android and iOS parts after making changes to the common parts. Ideally, all team members can have Android Studio and
Xcode installed to open and run both apps after making changes to the common code.

<table>
  <tr>
     <th>Pros</th>
     <th>Cons</th>
  </tr>
  <tr>
  <td>
    <list>
       <li>Both Android and iOS team members can easily edit Kotlin Multiplatform code, ensuring that creating and maintaining shared code is a shared responsibility. This breaks teams' isolation and encourages collaboration.</li>
       <li>It doesn't require separate versioning and publishing of the shared code.</li>
       <li>Quick development workflow as iOS team members don't have to wait for artifacts to be created and published.</li>
   </list>
</td>
<td>
  <list>
    <li>Team members need to set up a full development environment on their machines.</li>
    <li>iOS developers have to learn to use Android Studio and Gradle.</li>
    <li>Managing changes becomes difficult as more code is shared and the team grows.</li>
  </list>
</td>
</tr>
</table>

### Remote: artifact distribution

Remote distribution means that the framework artifact is published as a CocoaPod or a Swift package using SPM and consumed
by the iOS app. The Android app may consume the binary dependency either locally or remotely.

Remote distribution is often used to gradually introduce the technology to existing projects. It doesn't significantly
change the workflow and build processes for iOS developers. Teams with two or more repositories mainly use remote
distribution to store project code.

As a start, use [KMMBridge](https://kmmbridge.touchlab.co/docs/). It's a set of build tools that greatly simplifies the
remote distribution workflow. However, you can always set up a similar workflow for your specific use case by yourself:

![Remote artifact distribution](remote-artifact-distribution.svg){width=700}

<table>
  <tr>
     <th>Pros</th>
     <th>Cons</th>
  </tr>
  <tr>
  <td>Non-participating iOS team members don't have to code in Kotlin and learn how to use tools, such as Android Studio and Gradle. This lowers the barrier of entry for the team significantly.</td>
<td>
  <list>
    <li>Slower workflow for the iOS developers as the process of editing and building the shared code involves publishing and versioning.</li>
   <li>Debugging shared Kotlin code is too difficult on iOS.</li>
   <li>The likelihood of iOS team members contributing to shared code significantly decreases.</li>
   <li>The maintenance of the shared code rests entirely on the participating team members.</li>
  </list>
</td>
</tr>
</table>

#### Setting up a local dependency for local development

Many teams choose remote distribution workflow when adopting Kotlin Multiplatform technology to keep the development
process the same for iOS developers. However, it's hard for them to change Kotlin Multiplatform code in this workflow.
In this case, we recommend setting up an additional "local development" workflow with a local dependency on a framework
generated from the Kotlin Multiplatform module.

When developers add new functionality, they switch to consuming the Kotlin Multiplatform module as a local dependency.
That allows making changes to common Kotlin code, immediately observing the behavior from iOS, and debugging Kotlin
code. When the functionality is ready, they can switch back to the remote dependency and publish their changes
accordingly. First, they publish changes to the shared modules, and only after that do they make changes to the apps.

For remote distribution workflow, use either CocoaPods integration or SPM. For local distribution workflow, integrate
the framework directly.

<!-- This tutorial [TODO] describes how to switch the workflow by choosing the corresponding scheme in Xcode:
[TODO screenshot] -->

If you use CocoaPods, you can alternatively use CocoaPods for local distribution workflow and switch between them by
changing the environmental variable as described in the [TouchLab documentation](https://kmmbridge.touchlab.co/docs/cocoapods/IOS_LOCAL_DEV_COCOAPODS).
